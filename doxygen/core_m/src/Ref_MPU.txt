/**
\defgroup mpu_functions  MPU Functions (ARMv7)
\brief Functions that relate to the Memory Protection Unit.
\details
Devices based on Cortex-M processors M0+, M3, M4 and M7 optionally can contain a Memory Protection Unit.
If available the MPU can be used to prevent erroneous memory accesses.

<b>Example:</b>
\code
void main() 
{
  // Set Region 0
  ARM_MPU_SetRegionEx(0UL, 0x08000000UL, MPU_RASR(0UL, ARM_MPU_AP_FULL, 0UL, 0UL, 1UL, 1UL, 0x00UL, ARM_MPU_REGION_SIZE_1MB));
  
  ARM_MPU_Enable(0);
  
  // Do MPU protected stuff  
  
  ARM_MPU_Disable();
}
\endcode

@{
*/

/**
*/
typedef struct {} MPU_Type;

/** \def ARM_MPU_RBAR
* \brief MPU Region Base Address Register Value
*
* This preprocessor function can be used to construct a valid \ref MPU_Type::RBAR "RBAR" value.
* The VALID bit is implicitly set to 1.
*
* \param Region The region to be configured, number 0 to 15.
* \param BaseAddress The base address for the region.
*/
#define ARM_MPU_RBAR(Region, BaseAddress)

/**
* \def ARM_MPU_RASR
* \brief MPU Region Attribute and Size Register Value
*
* This preprocessor function can be used to construct a valid \ref MPU_Type::RASR "RASR" value.
* The ENABLE bit is implicitly set to 1.
*
* \param DisableExec       Instruction access disable bit, 1= disable instruction fetches.
* \param AccessPermission  Data access permissions, allows you to configure read/write access for User and Privileged mode. See \ref mpu_functions_access_permissions.
* \param TypeExtField      Type extension field, allows you to configure memory access type, for example strongly ordered, peripheral.
* \param IsShareable       Region is shareable between multiple bus masters.
* \param IsCacheable       Region is cacheable, i.e. its value may be kept in cache.
* \param IsBufferable      Region is bufferable, i.e. using write-back caching. Cacheable but non-bufferable regions use write-through policy.
* \param SubRegionDisable  Sub-region disable field.
* \param Size              Region size of the region be configured, for example 4K, 8K. See \ref mpu_functions_region_size.
*/                         
#define ARM_MPU_RASR(DisableExec, AccessPermission, TypeExtField, IsShareable, IsCacheable, IsBufferable, SubRegionDisable, Size)

/**
* \brief Struct for a single MPU Region
* \details An array of MPU Regions can be used to set up an MPU Table.
* Using a table of precompiled register values can be used at runtime to
* efficently update a bunch of regions at once using \ref ARM_MPU_Load.
* 
* <b>Example:</b>
* \code
* const ARM_MPU_Region_t mpuTable[3][4] = {
*   {
*     { .RBAR = ARM_MPU_RBAR(0UL, 0x08000000UL), .RASR = ARM_MPU_RASR(0UL, ARM_MPU_AP_FULL, 0UL, 0UL, 1UL, 1UL, 0x00UL, ARM_MPU_REGION_SIZE_1MB)  },
*     { .RBAR = ARM_MPU_RBAR(1UL, 0x20000000UL), .RASR = ARM_MPU_RASR(1UL, ARM_MPU_AP_FULL, 0UL, 0UL, 1UL, 1UL, 0x00UL, ARM_MPU_REGION_SIZE_32KB) },
*     { .RBAR = ARM_MPU_RBAR(2UL, 0x40020000UL), .RASR = ARM_MPU_RASR(1UL, ARM_MPU_AP_FULL, 2UL, 0UL, 0UL, 0UL, 0x00UL, ARM_MPU_REGION_SIZE_8KB)  }, 
*     { .RBAR = ARM_MPU_RBAR(3UL, 0x40022000UL), .RASR = ARM_MPU_RASR(1UL, ARM_MPU_AP_FULL, 2UL, 0UL, 0UL, 0UL, 0xC0UL, ARM_MPU_REGION_SIZE_4KB)  }
*   },
*   {
*     { .RBAR = ARM_MPU_RBAR(4UL, 0x08000000UL), .RASR = ARM_MPU_RASR(0UL, ARM_MPU_AP_FULL, 0UL, 0UL, 1UL, 1UL, 0x00UL, ARM_MPU_REGION_SIZE_1MB)  },
*     { .RBAR = ARM_MPU_RBAR(5UL, 0x20000000UL), .RASR = ARM_MPU_RASR(1UL, ARM_MPU_AP_FULL, 0UL, 0UL, 1UL, 1UL, 0x00UL, ARM_MPU_REGION_SIZE_32KB) },
*     { .RBAR = ARM_MPU_RBAR(6UL, 0x40020000UL), .RASR = ARM_MPU_RASR(1UL, ARM_MPU_AP_FULL, 2UL, 0UL, 0UL, 0UL, 0x00UL, ARM_MPU_REGION_SIZE_8KB)  }, 
*     { .RBAR = ARM_MPU_RBAR(7UL, 0x40022000UL), .RASR = ARM_MPU_RASR(1UL, ARM_MPU_AP_FULL, 2UL, 0UL, 0UL, 0UL, 0xC0UL, ARM_MPU_REGION_SIZE_4KB)  }
*   },
*   {
*     { .RBAR = ARM_MPU_RBAR(4UL, 0x18000000UL), .RASR = ARM_MPU_RASR(0UL, ARM_MPU_AP_FULL, 0UL, 0UL, 1UL, 1UL, 0x00UL, ARM_MPU_REGION_SIZE_1MB)  },
*     { .RBAR = ARM_MPU_RBAR(5UL, 0x30000000UL), .RASR = ARM_MPU_RASR(1UL, ARM_MPU_AP_FULL, 0UL, 0UL, 1UL, 1UL, 0x00UL, ARM_MPU_REGION_SIZE_32KB) },
*     { .RBAR = ARM_MPU_RBAR(6UL, 0x50020000UL), .RASR = ARM_MPU_RASR(1UL, ARM_MPU_AP_FULL, 2UL, 0UL, 0UL, 0UL, 0x00UL, ARM_MPU_REGION_SIZE_8KB)  }, 
*     { .RBAR = ARM_MPU_RBAR(7UL, 0x50022000UL), .RASR = ARM_MPU_RASR(1UL, ARM_MPU_AP_FULL, 2UL, 0UL, 0UL, 0UL, 0xC0UL, ARM_MPU_REGION_SIZE_4KB)  }
*   }
* };
* 
* void UpdateMpu(uint32_t idx)
* {
*    ARM_MPU_Load(mpuTable[idx], 4u);
* }
* \endcode
*
* \note As stream loading the MPU makes use of the REGION field in \ref MPU_Type::RBAR only up to 16 regions can be handled this way.
*/
typedef struct _ARM_MPU_Region_t {
    uint32_t RBAR; //!< The region base address register value (\ref MPU_Type::RBAR "RBAR")
    uint32_t RASR; //!< The region attribute and size register value (\ref MPU_Type::RASR "RASR"), see \ref ARM_MPU_RASR.
} ARM_MPU_Region_t;

/** Enable the MPU.
* \param MPU_Control Default access permissions for unconfigured regions.
*/
__STATIC_INLINE void ARM_MPU_Enable(uint32_t MPU_Control);

/** Disable the MPU.
*/
__STATIC_INLINE void ARM_MPU_Disable();

/** Clear and disable the given MPU region.
* \param rnr Region number to be cleared.
*/
__STATIC_INLINE void ARM_MPU_ClrRegion(uint32_t rnr);

/** Configure an MPU region.
*
* The region number should be contained in the rbar value.
*
* \param rbar Value for \ref MPU_Type::RBAR "RBAR" register.
* \param rasr Value for \ref MPU_Type::RASR "RASR" register.
*/ 
__STATIC_INLINE void ARM_MPU_SetRegion(uint32_t rbar, uint32_t rasr);

/** Configure the given MPU region.
* \param rnr Region number to be configured.
* \param rbar Value for \ref MPU_Type::RBAR "RBAR" register.
* \param rasr Value for \ref MPU_Type::RASR "RASR" register.
*/
__STATIC_INLINE void ARM_MPU_SetRegionEx(uint32_t rnr, uint32_t rbar, uint32_t rasr);

/** Load the given number of MPU regions from a table.
* \param table Pointer to the MPU configuration table.
* \param cnt Amount of regions to be configured.
*/
__STATIC_INLINE void ARM_MPU_Load(MPU_Region_t const* table, uint32_t cnt);


/**
 @}  
 
\defgroup mpu_functions_region_size Defines ARM_MPU_REGION_SIZE_ 
\ingroup mpu_functions
\brief Defines for valid MPU region sizes.
@{
*/

/** \def ARM_MPU_REGION_SIZE_32B
* \brief Region size 32 Bytes.
*/
#define ARM_MPU_REGION_SIZE_32B      ((uint8_t)0x04U)

/** \def ARM_MPU_REGION_SIZE_64B
* \brief Region size 64 Bytes.
*/
#define ARM_MPU_REGION_SIZE_64B      ((uint8_t)0x05U)

/** \def ARM_MPU_REGION_SIZE_128B
* \brief Region size 128 Bytes.
*/
#define ARM_MPU_REGION_SIZE_128B     ((uint8_t)0x06U)

/** \def ARM_MPU_REGION_SIZE_256B
* \brief Region size 256 Bytes.
*/
#define ARM_MPU_REGION_SIZE_256B     ((uint8_t)0x07U)

/** \def ARM_MPU_REGION_SIZE_512B
* \brief Region size 512 Bytes.
*/
#define ARM_MPU_REGION_SIZE_512B     ((uint8_t)0x08U)

/** \def ARM_MPU_REGION_SIZE_1KB
* \brief Region size 1KB.
*/
#define ARM_MPU_REGION_SIZE_1KB      ((uint8_t)0x09U)

/** \def ARM_MPU_REGION_SIZE_2KB
* \brief Region size 2KB.
*/
#define ARM_MPU_REGION_SIZE_2KB      ((uint8_t)0x0AU)

/** \def ARM_MPU_REGION_SIZE_4KB
* \brief Region size 4KB.
*/
#define ARM_MPU_REGION_SIZE_4KB      ((uint8_t)0x0BU)

/** \def ARM_MPU_REGION_SIZE_8KB
* \brief Region size 8KB.
*/
#define ARM_MPU_REGION_SIZE_8KB      ((uint8_t)0x0CU)

/** \def ARM_MPU_REGION_SIZE_16KB
* \brief Region size 16KB.
*/
#define ARM_MPU_REGION_SIZE_16KB     ((uint8_t)0x0DU)

/** \def ARM_MPU_REGION_SIZE_32KB
* \brief Region size 32KB.
*/
#define ARM_MPU_REGION_SIZE_32KB     ((uint8_t)0x0EU)

/** \def ARM_MPU_REGION_SIZE_64KB
* \brief Region size 64KB.
*/
#define ARM_MPU_REGION_SIZE_64KB     ((uint8_t)0x0FU)

/** \def ARM_MPU_REGION_SIZE_128KB
* \brief Region size 128KB.
*/
#define ARM_MPU_REGION_SIZE_128KB    ((uint8_t)0x10U)

/** \def ARM_MPU_REGION_SIZE_256KB
* \brief Region size 256KB.
*/
#define ARM_MPU_REGION_SIZE_256KB    ((uint8_t)0x11U)

/** \def ARM_MPU_REGION_SIZE_512KB
* \brief Region size 512KB.
*/
#define ARM_MPU_REGION_SIZE_512KB    ((uint8_t)0x12U)

/** \def ARM_MPU_REGION_SIZE_1MB
* \brief Region size 1MB.
*/
#define ARM_MPU_REGION_SIZE_1MB      ((uint8_t)0x13U)

/** \def ARM_MPU_REGION_SIZE_2MB
* \brief Region size 2MB.
*/
#define ARM_MPU_REGION_SIZE_2MB      ((uint8_t)0x14U)

/** \def ARM_MPU_REGION_SIZE_4MB
* \brief Region size 4MB.
*/
#define ARM_MPU_REGION_SIZE_4MB      ((uint8_t)0x15U)

/** \def ARM_MPU_REGION_SIZE_8MB
* \brief Region size 8MB.
*/
#define ARM_MPU_REGION_SIZE_8MB      ((uint8_t)0x16U)

/** \def ARM_MPU_REGION_SIZE_16MB
* \brief Region size 16MB.
*/
#define ARM_MPU_REGION_SIZE_16MB     ((uint8_t)0x17U)

/** \def ARM_MPU_REGION_SIZE_32MB
* \brief Region size 32MB.
*/
#define ARM_MPU_REGION_SIZE_32MB     ((uint8_t)0x18U)

/** \def ARM_MPU_REGION_SIZE_64MB
* \brief Region size 64MB.
*/
#define ARM_MPU_REGION_SIZE_64MB     ((uint8_t)0x19U)

/** \def ARM_MPU_REGION_SIZE_128MB
* \brief Region size 128MB.
*/
#define ARM_MPU_REGION_SIZE_128MB    ((uint8_t)0x1AU)

/** \def ARM_MPU_REGION_SIZE_256MB
* \brief Region size 256MB
*/
#define ARM_MPU_REGION_SIZE_256MB    ((uint8_t)0x1BU)

/** \def ARM_MPU_REGION_SIZE_512MB
* \brief Region size 512MB.
*/
#define ARM_MPU_REGION_SIZE_512MB    ((uint8_t)0x1CU)

/** \def ARM_MPU_REGION_SIZE_1GB
* \brief Region size 1GB.
*/
#define ARM_MPU_REGION_SIZE_1GB      ((uint8_t)0x1DU)

/** \def ARM_MPU_REGION_SIZE_2GB
* \brief Region size 2GB.
*/
#define ARM_MPU_REGION_SIZE_2GB      ((uint8_t)0x1EU)

/** \def ARM_MPU_REGION_SIZE_4GB
* \brief Region size 4GB.
*/
#define ARM_MPU_REGION_SIZE_4GB      ((uint8_t)0x1FU)

/**
 @}  
 
\defgroup mpu_functions_access_permissions Defines ARM_MPU_AP_
\ingroup mpu_functions
\brief Defines for valid MPU region access permissions
@{
*/

/** \def ARM_MPU_AP_NONE
* Access permissions: None. 
* Any access generates a permission fault.
*/
#define ARM_MPU_AP_NONE 0u 

/** \def ARM_MPU_AP_PRIV
* Access permissions: Privileged Read/Write. 
* Privileged access only. Any unprivileged access generates a permission fault.
*/
#define ARM_MPU_AP_PRIV 1u

/** \def ARM_MPU_AP_URO
* Access permissions: Privileged Read/Write. Unprivileged Read-only. 
* Any unprivileged write generates a permission fault.
*/
#define ARM_MPU_AP_URO  2u

/** \def ARM_MPU_AP_FULL
* Access permissions: Privileged Read/Write. Unprivileged Read/Write. 
* Full access, permission faults are never generated.
*/
#define ARM_MPU_AP_FULL 3u

/** \def ARM_MPU_AP_PRO
* Access permissions: Privileged Read-only.
* Any unprivileged access or privileged write generates a permission fault.
*/
#define ARM_MPU_AP_PRO  5u

/** \def ARM_MPU_AP_RO
* Access permissions: Privileged and Unprivileged Read-only.
* Any write generates a permission fault.
*/
#define ARM_MPU_AP_RO   6u
 
/** @} */

/** 

\var ARM_MPU_Region_t::RBAR
This value specifies the start address of the MPU protected memory region.
The address must be a multiple of the region size, i.e. size aligned.

See \ref MPU_Type::RBAR for details about field bit format.

\var ARM_MPU_Region_t::RASR
This value specifies the size of the MPU protected memory region.

Valid values are limited to sizes 
- of at least 32 bytes, and
- with power of 2

Use one of the \ref mpu_functions_region_size.

\var MPU_Type::TYPE
The MPU Type Register indicates how many regions the MPU support. Software can use it
to determine if the processor implements an MPU.

| Bits    | Name          | Function                                                      |
| :------ | :------------ | :------------------------------------------------------------ |
| [31:24] | -             | Reserved.                                                     |
| [23:16] | IREGION       | Instruction region. RAZ. ARMv7-M only supports a unified MPU. |
| [15:8]  | DREGION       | Number of regions supported by the MPU. If this field reads-as-zero the processor does not implement an MPU. |
| [7:1]   | -             | Reserved.                                                     |
| [0]     | SEPARATE      | Indicates support for separate instruction and data address maps. RAZ. ARMv7-M only supports a unified MPU. |

\var MPU_Type::CTRL
Enables the MPU, and when the MPU is enabled, controls whether the default memory map
is enabled as a background region for privileged accesses, and whether the MPU is enabled
for HardFaults, NMIs, and exception handlers when FAULTMASK is set to 1.

| Bits    | Name          | Function                                                      |
| :------ | :------------ | :------------------------------------------------------------ |
| [31:3]  | -             | Reserved.                                                     |
| [2]     | PRIVDEFENA    | 0 - Disables the default memory map. 1 - Enables the default memory map as a background region for privileged access. |
| [1]     | HFNMIENA      | 0 - Disables the MPU for exception handlers. 1 - Use the MPU for memory accesses by exception handlers. |
| [0]     | ENABLE        | 0 - The MPU is disabled. 1 - The MPU is enabled.              |

\var MPU_Type::RNR    
Selects the region currently accessed by \ref MPU_Type::RBAR and \ref MPU_Type::RASR.

| Bits    | Name          | Function                                                      |
| :------ | :------------ | :------------------------------------------------------------ |
| [31:8]  | -             | Reserved.                                                     |
| [7:0]   | REGION        | Indicates the memory region accessed.                         |

\var MPU_Type::RBAR  
Holds the base address of the region identified by MPU_RNR. On a write, can also be used
to update the base address of a specified region, in the range 0 to 15, updating MPU_RNR
with the new region number.
 
| Bits    | Name          | Function                                                      |
| :------ | :------------ | :------------------------------------------------------------ |
| [31:5]  | ADDR          | Base address of the region.                                   |
| [4]     | VALID         | 1 - Update \ref MPU_Type::RNR to the value obtained by zero extending the REGION value specified in this write, and apply the base address update to this region. |
| [3:0]   | REGION        | On writes, can specify the number of the region to update, see VALID field description. |

\var MPU_Type::RASR
Defines the size and access behavior of the region identified by MPU_RNR, and enables
that region.

| Bits    | Name          | Function                                                      |
| :------ | :------------ | :------------------------------------------------------------ |
| [31:29] | -             | Reserved.                                                     |
| [28]    | XN            | Execute Never.                                                |
| [27]    | -             | Reserved.                                                     |
| [26:24] | AP            | Access Permissions, see \ref mpu_functions_access_permissions. |
| [23:22] | -             | Reserved.                                                     |
| [21:19] | TEX           | Type Extension.                                               |
| [18]    | S             | Shareable.                                                    |
| [17]    | C             | Cacheable.                                                    |
| [16]    | B             | Bufferable.                                                   |
| [15:8]  | SRD           | Subregion Disable. For regions of 256 bytes or larger, each bit of this field controls whether one of the eight equal subregions is enabled (0) or disabled (1). 
| [7:6]   | -             | Reserved.                                                     |
| [5:1]   | SIZE          | Indicates the region size. The region size, in bytes, is 2(SIZE+1). SIZE field values less than 4 are reserved, because the smallest supported region size is 32 bytes. |
| [0]     | ENABLE        | 0 - This region is disabled. 1 - This region is enabled.      |

\var MPU_Type::RBAR_A1
Alias for \ref MPU_Type::RBAR.

\var MPU_Type::RASR_A1
Alias for \ref MPU_Type::RASR.

\var MPU_Type::RBAR_A2
Alias for \ref MPU_Type::RBAR.

\var MPU_Type::RASR_A2
Alias for \ref MPU_Type::RASR.

\var MPU_Type::RBAR_A3
Alias for \ref MPU_Type::RBAR.

\var MPU_Type::RASR_A3
Alias for \ref MPU_Type::RASR.

*/
